#ifndef OPENAGE_PATHFINDING_PATH_H_
#define OPENAGE_PATHFINDING_PATH_H_

#include <functional>
#include <list>
#include <vector>

#include "../coord/tile.h"
#include "../util/misc.h"


namespace openage {
namespace path {

class Node;
class Path;

/**
 * the data type for movement cost
 */
using cost_t = float;

/**
 * function pointer type for distance estimation functions.
 */
using heuristic_t = cost_t (*)(const Node &start, const Node &end);

/**
 * One waypoint in a path.
 */
class Node {
public:
	Node();
	~Node();

	/**
	 * Orders nodes according to their future cost value.
	 */
	bool operator <(const Node &other) const;

	/**
	 * Compare the node to another one.
	 * They are the same if their position is.
	 */
	bool operator ==(const Node &other) const;

	/**
	 * Calculates the actual movement cose to another node.
	 */
	cost_t cost_to(const Node &other) const;

	/**
	 * Create a backtrace path beginning at this node.
	 */
	Path generate_backtrace() const;

	/**
	 * Get all neighbors of this graph node.
	 */
	std::vector<Node> get_neighbors() const;

	/**
	 * The tile position this node is associated to.
	 */
	coord::tile position;

	/**
	 * Future cost estimation value for this node.
	 */
	cost_t future_cost;

	/**
	 * Evaluated past cost value for the node.
	 * This stores the actual cost from start to this node.
	 */
	cost_t past_cost;

	/**
	 * Heuristic cost cache.
	 * Calculated once, is the heuristic distance from this node
	 * to the goal.
	 */
	cost_t heuristic_cost;

	/**
	 * Can this node be passed?
	 */
	bool accessible;

	/**
	 * Has this Node been visited?
	 */
	bool visited;

	/**
	 * Does this node already have an alternative path?
	 * If the node was once selected as the best next hop,
	 * this is set to true.
	 */
	bool was_best;

	/**
	 * Factor to adjust movement cost.
	 * default: 1
	 */
	cost_t factor;

	/**
	 * Node where this one was reached by least cost.
	 */
	Node *path_predecessor;
};


/**
 * Represents a planned trajectory.
 * Generated by pathfinding algorithms.
 */
class Path {
public:
	Path();
	Path(const std::list<Node> &nodes);
	~Path();

private:
	/**
	 * These are the waypoints to navigate in order.
	 * Includes the start and end node.
	 */
	std::list<Node> waypoints;
};


} // namespace path
} // namespace openage


namespace std {

/**
 * Hash function for path nodes.
 * Just uses their position.
 * TODO: tile_t should provide its own hash function.
 */
template <>
struct hash<openage::path::Node &> {
	size_t operator ()(const openage::path::Node &x) const {
		openage::coord::tile node_pos = x.position;
		size_t nehash = std::hash<openage::coord::tile_t>{}(node_pos.ne);
		size_t sehash = std::hash<openage::coord::tile_t>{}(node_pos.se);
		return openage::util::rol<size_t, 1>(nehash) ^ sehash;
	}
};

} // namespace std



#endif
